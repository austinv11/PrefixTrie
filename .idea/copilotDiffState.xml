<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/debug_exact.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug_exact.py" />
              <option name="updatedContent" value="import pyximport&#10;pyximport.install()&#10;from prefixtrie._impl import cPrefixTrie&#10;&#10;# Test the exact flag issue&#10;print(&quot;=== Testing exact flag behavior ===&quot;)&#10;&#10;entries = [&quot;hello&quot;, &quot;help&quot;, &quot;helicopter&quot;]&#10;trie = cPrefixTrie(entries, allow_indels=True)&#10;&#10;# Test the failing case&#10;result, exact = trie.search(&quot;helllo&quot;, correction_budget=1)&#10;print(f&quot;'helllo' -&gt; '{result}', exact={exact} (should be exact=False)&quot;)&#10;&#10;# Test some other cases for comparison&#10;result, exact = trie.search(&quot;hello&quot;, correction_budget=1)&#10;print(f&quot;'hello' -&gt; '{result}', exact={exact} (should be exact=True)&quot;)&#10;&#10;result, exact = trie.search(&quot;hallo&quot;, correction_budget=1)&#10;print(f&quot;'hallo' -&gt; '{result}', exact={exact} (should be exact=False)&quot;)&#10;&#10;# Test without budget (should only find exact matches)&#10;result, exact = trie.search(&quot;helllo&quot;, correction_budget=0)&#10;print(f&quot;'helllo' (budget=0) -&gt; '{result}', exact={exact} (should be None)&quot;)&#10;&#10;# Test if it's actually the same string&#10;print(f&quot;\nString comparison: 'helllo' == 'hello': {'helllo' == 'hello'}&quot;)&#10;print(f&quot;Lengths: 'helllo'={len('helllo')}, 'hello'={len('hello')}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/debug_insertion.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug_insertion.py" />
              <option name="updatedContent" value="import pyximport&#10;pyximport.install()&#10;from prefixtrie._impl import cPrefixTrie&#10;&#10;# Test the specific insertion issue&#10;print(&quot;=== Testing insertion logic ===&quot;)&#10;&#10;# Simple case: &quot;hel&quot; should find &quot;help&quot; with 1 insertion&#10;trie = cPrefixTrie([&quot;help&quot;], allow_indels=True)&#10;result, exact = trie.search(&quot;hel&quot;, correction_budget=1)&#10;print(f&quot;'hel' -&gt; 'help': {result} (should be 'help')&quot;)&#10;&#10;# Even simpler case: &quot;he&quot; should find &quot;help&quot; with 2 insertions&#10;result, exact = trie.search(&quot;he&quot;, correction_budget=2)&#10;print(f&quot;'he' -&gt; 'help': {result} (should be 'help')&quot;)&#10;&#10;# Test at trie boundary: &quot;h&quot; should find &quot;help&quot; with 3 insertions&#10;result, exact = trie.search(&quot;h&quot;, correction_budget=3)&#10;print(f&quot;'h' -&gt; 'help': {result} (should be 'help')&quot;)&#10;&#10;# Test empty string should find &quot;help&quot; with 4 insertions&#10;result, exact = trie.search(&quot;&quot;, correction_budget=4)&#10;print(f&quot;'' -&gt; 'help': {result} (should be 'help')&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/debug_test.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug_test.py" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="import pyximport&#10;pyximport.install()&#10;from prefixtrie._impl import cPrefixTrie&#10;&#10;# Debug the failing test case&#10;print(&quot;=== Debugging insertion/deletion behavior ===&quot;)&#10;&#10;entries = [&quot;hello&quot;, &quot;help&quot;, &quot;helicopter&quot;]&#10;trie = cPrefixTrie(entries, allow_indels=True)&#10;&#10;# Test the failing case&#10;query = &quot;helo&quot;&#10;result, exact = trie.search(query, correction_budget=1)&#10;print(f&quot;Query: '{query}' -&gt; Result: '{result}', Exact: {exact}&quot;)&#10;print(f&quot;Expected: 'hello' (insertion of 'l')&quot;)&#10;print(f&quot;Actual result needs: {len(query)} -&gt; {len(result)} chars&quot;)&#10;&#10;# Let's test what happens with different queries&#10;test_cases = [&#10;    (&quot;helo&quot;, 1),    # missing 'l' - should be &quot;hello&quot;&#10;    (&quot;hel&quot;, 1),     # missing 'p' - should be &quot;help&quot;&#10;    (&quot;helllo&quot;, 1),  # extra 'l' - should be &quot;hello&quot;&#10;    (&quot;helpx&quot;, 1),   # extra 'x' - should be &quot;help&quot;&#10;]&#10;&#10;print(&quot;\n=== Testing various edit scenarios ===&quot;)&#10;for query, budget in test_cases:&#10;    result, exact = trie.search(query, correction_budget=budget)&#10;    print(f&quot;'{query}' (budget={budget}) -&gt; '{result}' (exact={exact})&quot;)&#10;&#10;# Test with each entry individually to see algorithm preference&#10;print(&quot;\n=== Testing with individual entries ===&quot;)&#10;for entry in entries:&#10;    single_trie = cPrefixTrie([entry], allow_indels=True)&#10;    result, exact = single_trie.search(&quot;helo&quot;, correction_budget=1)&#10;    print(f&quot;Single entry '{entry}': 'helo' -&gt; '{result}' (exact={exact})&quot;)&#10;&#10;# Test edit distances manually&#10;print(&quot;\n=== Manual edit distance analysis ===&quot;)&#10;print(&quot;'helo' -&gt; 'hello': 1 insertion (insert 'l' at position 2)&quot;)&#10;print(&quot;'helo' -&gt; 'help': 1 substitution ('o' -&gt; 'p') + 1 deletion (remove 'o')&quot;)&#10;print(&quot;Wait, that's wrong. Let me recalculate:&quot;)&#10;print(&quot;'helo' -&gt; 'help': actually needs 2 edits (substitute 'o'-&gt;'p', then what?)&quot;)&#10;print()&#10;print(&quot;Let's check character by character:&quot;)&#10;print(&quot;helo -&gt; hello: h=h, e=e, l=l, o-&gt;l (substitute), +o (insert) = 2 edits&quot;)&#10;print(&quot;helo -&gt; help:  h=h, e=e, l=l, o-&gt;p (substitute) = 1 edit&quot;)&#10;print()&#10;print(&quot;Actually, I think 'help' IS the correct answer for 'helo' with 1 edit!&quot;)&#10;&#10;# Debug another failing case&#10;print(&quot;\n=== Debugging 'hell' case ===&quot;)&#10;query = &quot;hell&quot;&#10;result, exact = trie.search(query, correction_budget=1)&#10;print(f&quot;Query: '{query}' -&gt; Result: '{result}', Exact: {exact}&quot;)&#10;&#10;print(&quot;\nEdit distance analysis:&quot;)&#10;print(&quot;'hell' -&gt; 'hello': insert 'o' at end = 1 edit&quot;)&#10;print(&quot;'hell' -&gt; 'help': substitute 'l'-&gt;'p' at position 3 = 1 edit&quot;)&#10;print(&quot;Both require exactly 1 edit, so either could be valid!&quot;)&#10;&#10;# Debug the &quot;hel&quot; case&#10;print(&quot;\n=== Debugging 'hel' case ===&quot;)&#10;query = &quot;hel&quot;&#10;result, exact = trie.search(query, correction_budget=1)&#10;print(f&quot;Query: '{query}' -&gt; Result: '{result}', Exact: {exact}&quot;)&#10;&#10;print(&quot;\nEdit distance analysis:&quot;)&#10;print(&quot;'hel' -&gt; 'hello': insert 'l' at pos 3, insert 'o' at pos 4 = 2 edits&quot;)&#10;print(&quot;'hel' -&gt; 'help': insert 'p' at pos 3 = 1 edit&quot;)&#10;print(&quot;'hel' -&gt; 'helicopter': insert many chars = many edits&quot;)&#10;&#10;# Test with individual entries&#10;print(&quot;\n=== Testing 'hel' with individual entries ===&quot;)&#10;for entry in entries:&#10;    single_trie = cPrefixTrie([entry], allow_indels=True)&#10;    result, exact = single_trie.search(&quot;hel&quot;, correction_budget=1)&#10;    print(f&quot;Single entry '{entry}': 'hel' -&gt; '{result}' (exact={exact})&quot;)&#10;&#10;# Test what happens with budget 2&#10;result, exact = trie.search(&quot;hel&quot;, correction_budget=2)&#10;print(f&quot;\nWith budget 2: 'hel' -&gt; '{result}' (exact={exact})&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/prefixtrie/_impl.pyx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/prefixtrie/_impl.pyx" />
              <option name="originalContent" value="# distutils: language = c++&#10;# cython: language_level=3, boundscheck=False, wraparound=False, cdivision=True, infer_types=True, initializedcheck=False, nonecheck=False&#10;&#10;from libc.stdlib cimport malloc, free&#10;from libc.stddef cimport size_t&#10;from libc.string cimport strcpy, strlen, memcpy, strncmp, memset&#10;from libcpp.unordered_map cimport unordered_map&#10;from libcpp.utility cimport pair&#10;from libcpp.vector cimport vector&#10;from cython.operator cimport dereference as deref, preincrement as preinc&#10;from cpython.unicode cimport PyUnicode_AsUTF8AndSize, PyUnicode_FromString&#10;import cython&#10;&#10;# -----------------------------&#10;# Low-level string helpers&#10;# -----------------------------&#10;ctypedef char* Str&#10;&#10;cdef Str py_str_to_c_str(str py_str):&#10;    cdef Py_ssize_t n_bytes&#10;    cdef const char* buf = PyUnicode_AsUTF8AndSize(py_str, &amp;n_bytes)&#10;    cdef Str c_str = &lt;Str&gt; malloc(n_bytes + 1)&#10;    if not c_str:&#10;        raise MemoryError(&quot;Failed to allocate memory for C string&quot;)&#10;    memcpy(c_str, buf, n_bytes)&#10;    c_str[n_bytes] = '\0'&#10;    return c_str&#10;&#10;cdef str c_str_to_py_str(const Str c_str):&#10;    if c_str == NULL:&#10;        return None&#10;    return PyUnicode_FromString(c_str)&#10;&#10;# -----------------------------&#10;# Trie node &amp; construction&#10;# -----------------------------&#10;&#10;ctypedef struct Alphabet:&#10;    size_t size&#10;    int map[256]  # Assuming ASCII, max 256 characters&#10;&#10;cdef struct TrieNode:&#10;    int node_id&#10;    char value&#10;    Str collapsed&#10;    size_t collapsed_len&#10;    TrieNode** children&#10;    vector[int]* children_idx&#10;    TrieNode* skip_to&#10;    TrieNode* parent&#10;    Str leaf_value&#10;&#10;cdef TrieNode* create_node(const int node_id, const char value, TrieNode* parent, const size_t alphabet_size):&#10;    cdef TrieNode* node = &lt;TrieNode*&gt;malloc(sizeof(TrieNode))&#10;    if not node:&#10;        raise MemoryError(&quot;Failed to allocate memory for TrieNode&quot;)&#10;    node.node_id = node_id&#10;    node.value = value&#10;    node.collapsed = NULL&#10;    node.skip_to = NULL&#10;    node.children = &lt;TrieNode**&gt; malloc(alphabet_size * sizeof(TrieNode*))  # Allocate space for children pointers&#10;    if not node.children:&#10;        raise MemoryError(&quot;Failed to allocate memory for TrieNode children&quot;)&#10;    memset(node.children, 0, alphabet_size * sizeof(TrieNode*))  # Initialize to NULL&#10;    node.children_idx = new vector[int]()&#10;    deref(node.children_idx).reserve(4)&#10;    node.parent = parent&#10;    node.leaf_value = NULL&#10;    return node&#10;&#10;cdef inline size_t n_children(const TrieNode* n) noexcept nogil:&#10;    return deref(n.children_idx).size()&#10;&#10;cdef inline TrieNode* child_at(const TrieNode* n, const size_t i) noexcept nogil:&#10;    cdef int idx = deref(n.children_idx)[i]&#10;    return n.children[idx]&#10;&#10;cdef inline void append_child_at_index(TrieNode* p, TrieNode* c, int idx) noexcept nogil:&#10;    p.children[idx] = c&#10;    c.parent = p&#10;    deref(p.children_idx).push_back(idx)&#10;&#10;cdef inline bint is_leaf(const TrieNode* node) noexcept nogil:&#10;    return n_children(node) == 0&#10;&#10;cdef inline bint has_complete(const TrieNode* node) noexcept nogil:&#10;    return is_leaf(node) or node.leaf_value != NULL&#10;&#10;# -----------------------------&#10;# Search result POD&#10;# -----------------------------&#10;&#10;cdef struct SearchResult:&#10;    bint found&#10;    Str found_str&#10;    int corrections&#10;&#10;cdef inline bint _is_better(const SearchResult* a, const SearchResult* b) noexcept nogil:&#10;    if a.found != b.found:&#10;        return a.found and not b.found&#10;    return a.corrections &lt; b.corrections&#10;&#10;# -----------------------------&#10;# Pure C++ cache (opaque to Python)&#10;# -----------------------------&#10;&#10;ctypedef unsigned long long Key  # Cache key, bit magic used to hold state&#10;&#10;cdef inline Key make_key(const int node_id, const size_t curr_idx, const bint allow_indels) noexcept nogil:&#10;    return ((&lt;unsigned long long&gt; node_id) &lt;&lt; 33) | ((&lt;unsigned long long&gt; curr_idx) &lt;&lt; 1) | (&#10;        &lt;unsigned long long&gt; (allow_indels &amp; 1))&#10;&#10;cdef struct CacheState:&#10;    unordered_map[Key, SearchResult]* data&#10;&#10;cdef inline CacheState* cache_new() nogil:&#10;    cdef CacheState* st = &lt;CacheState*&gt; malloc(sizeof(CacheState))&#10;    if st == NULL:&#10;        with gil:&#10;            raise MemoryError(&quot;Failed to allocate CacheState&quot;)&#10;    st.data = new unordered_map[Key, SearchResult]()&#10;    return st&#10;&#10;cdef inline void cache_reserve(CacheState* st, size_t query_len) noexcept nogil:&#10;    # Speed up allocations by pre-reserving a rough guesstimate on initial size&#10;    deref(st.data).reserve(8 * query_len)&#10;&#10;cdef inline void cache_free(CacheState* st) noexcept nogil:&#10;    if st != NULL:&#10;        if st.data != NULL:&#10;            del st.data  # delete C++ unordered_map&#10;        free(st)&#10;&#10;cdef inline bint cache_contains(const CacheState* st, const Key key) noexcept nogil:&#10;    return deref(st.data).find(key) != deref(st.data).end()&#10;&#10;cdef inline SearchResult cache_get(const CacheState* st, const Key key) noexcept nogil:&#10;    cdef unordered_map[Key, SearchResult].iterator it&#10;    cdef SearchResult out&#10;    out.found = False&#10;    out.found_str = NULL&#10;    out.corrections = 0&#10;    it = deref(st.data).find(key)&#10;    if it != deref(st.data).end():&#10;        out = deref(it).second&#10;    return out&#10;&#10;cdef inline bint cache_insert_if_better(CacheState* st, Key key, SearchResult incoming) noexcept nogil:&#10;    cdef unordered_map[Key, SearchResult].iterator it&#10;    cdef pair[Key, SearchResult] p&#10;    it = deref(st.data).find(key)&#10;    if it == deref(st.data).end():&#10;        p.first = key&#10;        p.second = incoming&#10;        deref(st.data).insert(p)&#10;        return True&#10;    else:&#10;        if _is_better(&amp;incoming, &amp;deref(it).second):&#10;            deref(it).second = incoming&#10;            return True&#10;        else:&#10;            return False&#10;&#10;# -----------------------------&#10;# Trie object (only search() exposed to Python)&#10;# -----------------------------&#10;@cython.final&#10;@cython.no_gc&#10;cdef class cPrefixTrie:&#10;    cdef TrieNode* root&#10;    cdef int n_entries&#10;    cdef bint allow_indels&#10;    cdef Alphabet alphabet&#10;&#10;    def __init__(self, entries: list[str], allow_indels: bool=False):&#10;        # Scan for alphabet to optimize lookups&#10;        cdef bint[256] seen&#10;        cdef int i, j&#10;        cdef Str c_entry&#10;        cdef str entry&#10;        for i in range(256):&#10;            seen[i] = 0&#10;        for entry in entries:&#10;            c_entry = py_str_to_c_str(entry)&#10;            for j in range(&lt;int&gt; strlen(c_entry)):&#10;                seen[&lt;unsigned char&gt; c_entry[j]] = True&#10;            free(c_entry)&#10;        self.alphabet.size = 0&#10;        for i in range(256):&#10;            if seen[i]:&#10;                self.alphabet.map[i] = &lt;int&gt; self.alphabet.size&#10;                self.alphabet.size += 1&#10;            else:&#10;                self.alphabet.map[i] = -1&#10;&#10;        self.root = create_node(0, '\0', NULL, &lt;size_t&gt; self.alphabet.size)&#10;        self.n_entries = 0&#10;        self.allow_indels = allow_indels&#10;        cdef int last_id = 1&#10;        for entry in entries:&#10;            last_id = self._insert(entry, last_id)&#10;            self.n_entries += 1&#10;        self._compile(self.root)&#10;&#10;    cdef int _insert(self, str entry, size_t last_id):&#10;        cdef TrieNode* node = self.root&#10;        cdef char ch&#10;        cdef bint found&#10;        cdef TrieNode* last_node = NULL&#10;        cdef TrieNode* new_node = NULL&#10;        cdef Str c_entry = py_str_to_c_str(entry)&#10;        cdef size_t i, k, n = strlen(c_entry)&#10;        cdef int idx, idx_next&#10;&#10;        for i in range(n):&#10;            ch = c_entry[i]&#10;            idx = self.alphabet.map[&lt;unsigned char&gt; ch]&#10;            if idx &lt; 0:&#10;                raise ValueError(&quot;Character not in alphabet&quot;)&#10;            if node.children[idx] != NULL:&#10;                node = node.children[idx]&#10;            else:&#10;                for k in range(n-1, i-1, -1):&#10;                    new_node = create_node(last_id, c_entry[k], NULL, &lt;size_t&gt; self.alphabet.size)&#10;                    last_id += 1&#10;                    if k == n - 1:&#10;                        new_node.leaf_value = &lt;Str&gt; malloc(strlen(c_entry) + 1)&#10;                        if not new_node.leaf_value:&#10;                            raise MemoryError(&quot;Failed to allocate memory for leaf value&quot;)&#10;                        strcpy(new_node.leaf_value, c_entry)&#10;                    if last_node != NULL:&#10;                        idx_next = self.alphabet.map[&lt;unsigned char&gt; last_node.value]&#10;                        append_child_at_index(new_node, last_node, idx_next)&#10;                    last_node = new_node&#10;                append_child_at_index(node, last_node, idx)&#10;                break&#10;&#10;        free(c_entry)&#10;        return last_id&#10;&#10;    cdef void _compile(self, TrieNode* node):&#10;        cdef size_t i&#10;        cdef TrieNode* child&#10;        cdef size_t clen&#10;        if not node:&#10;            return&#10;&#10;        if has_complete(node):&#10;            node.collapsed = &lt;Str&gt;malloc(2)&#10;            if not node.collapsed:&#10;                raise MemoryError(&quot;Failed to allocate memory for collapsed value&quot;)&#10;            node.collapsed[0] = node.value&#10;            node.collapsed[1] = '\0'&#10;            node.collapsed_len = 1&#10;            node.skip_to = node&#10;            if is_leaf(node):  # It is a leaf, so we are done&#10;                return&#10;&#10;        if n_children(node) == 1:&#10;            self._compile(child_at(node, 0))&#10;            # Root (value == '\0') should not prefix its value&#10;            if node.value == '\0':&#10;                node.collapsed = &lt;Str&gt;malloc(strlen(child_at(node, 0).collapsed) + 1)&#10;                if not node.collapsed:&#10;                    raise MemoryError(&quot;Failed to allocate memory for collapsed value&quot;)&#10;                strcpy(node.collapsed, child_at(node, 0).collapsed)&#10;                node.collapsed_len = child_at(node, 0).collapsed_len&#10;            else:&#10;                clen = child_at(node, 0).collapsed_len&#10;                node.collapsed = &lt;Str&gt;malloc(clen + 2)  # +1 for node.value, +1 for '\0'&#10;                if not node.collapsed:&#10;                    raise MemoryError(&quot;Failed to allocate memory for collapsed value&quot;)&#10;                node.collapsed[0] = node.value&#10;                strcpy(node.collapsed + 1, child_at(node, 0).collapsed)&#10;                node.collapsed_len = clen + (1 if node.value != '\0' else 0)&#10;            node.skip_to = child_at(node, 0).skip_to&#10;        else:&#10;            for i in range(n_children(node)):&#10;                child = child_at(node, i)&#10;                self._compile(child)&#10;            node.collapsed = &lt;Str&gt;malloc(2)&#10;            if not node.collapsed:&#10;               raise MemoryError(&quot;Failed to allocate memory for collapsed value&quot;)&#10;            node.collapsed[0] = node.value&#10;            node.collapsed[1] = '\0'&#10;            node.collapsed_len = 1&#10;            node.skip_to = node&#10;&#10;    cpdef tuple[object, bint] search(self, str query, int correction_budget=0):&#10;        cdef Str c_query = py_str_to_c_str(query)&#10;        cdef object found_str_py = None&#10;        cdef size_t query_len = strlen(c_query)&#10;        cdef CacheState* st = cache_new()&#10;        cache_reserve(st, query_len)  # Pre-allocate some space&#10;        cdef SearchResult res&#10;        with nogil:&#10;            res = self._search(&#10;                st, self.root, c_query, query_len,&#10;                0, 0, correction_budget, self.allow_indels, False&#10;            )&#10;        if res.found:&#10;            found_str_py = c_str_to_py_str(res.found_str)&#10;        cdef bint exact = res.found and (res.corrections == 0)&#10;        cache_free(st)  # frees all owned SearchResult*&#10;        free(c_query)&#10;        return (found_str_py, exact)&#10;&#10;    cdef SearchResult _search(self,&#10;                               CacheState* st,&#10;                               TrieNode* node,&#10;                               Str query,&#10;                               size_t query_len,&#10;                               size_t curr_idx,&#10;                               int curr_corrections,&#10;                               int max_corrections,&#10;                               bint allow_indels,&#10;                               bint exact_only) noexcept nogil:&#10;        # If there is no more remaining corrections, we can get some speed ups by annotating exact_only as true&#10;        exact_only = exact_only or (curr_corrections &gt;= max_corrections)&#10;&#10;        cdef SearchResult result&#10;        cdef SearchResult potential&#10;        cdef SearchResult prev&#10;        cdef bint is_at_query_end = (query_len == curr_idx)&#10;        cdef size_t i&#10;        cdef char query_char&#10;        cdef size_t skip_len&#10;&#10;        result.found = False&#10;        result.corrections = curr_corrections&#10;        result.found_str = NULL&#10;&#10;        # Cache check&#10;        cdef Key node_key = make_key(node.node_id, curr_idx, allow_indels)&#10;        prev = cache_get(st, node_key)&#10;        if cache_contains(st, node_key):&#10;            prev = cache_get(st, node_key)&#10;            if prev.corrections &lt;= curr_corrections:&#10;                return prev&#10;&#10;        # Base cases&#10;        if is_at_query_end and has_complete(node):&#10;            result.found = True&#10;            result.found_str = node.leaf_value&#10;            if not cache_insert_if_better(st, node_key, result):&#10;                return cache_get(st, node_key)&#10;            return result&#10;&#10;        if is_at_query_end and (not allow_indels or curr_corrections &gt;= max_corrections):&#10;            if not cache_insert_if_better(st, node_key, result):&#10;                return cache_get(st, node_key)&#10;            return result&#10;&#10;        if (not is_at_query_end) and is_leaf(node) and (not allow_indels or curr_corrections &gt;= max_corrections):&#10;            if not cache_insert_if_better(st, node_key, result):&#10;                return cache_get(st, node_key)&#10;            return result&#10;&#10;        # Collapsed exact skip&#10;        if node.collapsed is not NULL and node.skip_to is not NULL and node.skip_to != node:&#10;            skip_len = node.collapsed_len&#10;            if curr_idx + skip_len &lt;= query_len and strncmp(node.collapsed, query + curr_idx, skip_len) == 0:&#10;                potential = self._search(st, node.skip_to, query, query_len, curr_idx + skip_len,&#10;                                         curr_corrections, max_corrections, allow_indels, exact_only)&#10;                if potential.found and (exact_only or potential.corrections &lt;= curr_corrections or not allow_indels):&#10;                    return potential&#10;                # Otherwise cache it and continue exploring&#10;                cache_insert_if_better(st, make_key(node.skip_to.node_id, curr_idx + skip_len, allow_indels), potential)&#10;&#10;        # Exact character match (O(1) via alphabet index)&#10;        cdef int ai&#10;        if curr_idx &lt; query_len:&#10;            query_char = query[curr_idx]&#10;            ai = self.alphabet.map[&lt;unsigned char&gt; query_char]&#10;            if ai &gt;= 0:&#10;                if node.children[ai] != NULL:&#10;                    potential = self._search(st, node.children[ai], query, query_len, curr_idx + 1,&#10;                                             curr_corrections, max_corrections, allow_indels, exact_only)&#10;                    if potential.found:&#10;                        return potential&#10;                    cache_insert_if_better(st, make_key(node.children[ai].node_id, curr_idx + 1, allow_indels), potential)&#10;&#10;        # No budget to correct&#10;        if exact_only or curr_corrections &gt;= max_corrections:&#10;            if not cache_insert_if_better(st, node_key, result):&#10;                return cache_get(st, node_key)&#10;            else:&#10;                return result&#10;&#10;        # Try mismatches (iterate only existing children indices)&#10;        cdef size_t m&#10;        cdef int want&#10;        cdef int idx_child&#10;        if curr_idx &lt; query_len:&#10;            query_char = query[curr_idx]&#10;            want = self.alphabet.map[&lt;unsigned char&gt; query_char]&#10;            m = n_children(node)&#10;            for i in range(m):&#10;                idx_child = deref(node.children_idx)[i]&#10;                if idx_child == want:&#10;                    continue&#10;                potential = self._search(st, node.children[idx_child], query, query_len, curr_idx + 1,&#10;                                         curr_corrections + 1, max_corrections, allow_indels, exact_only)&#10;                if potential.found:&#10;                    return potential&#10;                cache_insert_if_better(st, make_key(node.children[idx_child].node_id, curr_idx + 1, allow_indels), potential)&#10;&#10;        # Try indels if allowed&#10;        if allow_indels:&#10;            # insertion allowing further indels&#10;            potential = self._search(st, node, query, query_len, curr_idx + 1,&#10;                                     curr_corrections + 1, max_corrections, True, exact_only)&#10;            if potential.found:&#10;                return potential&#10;            cache_insert_if_better(st, make_key(node.node_id, curr_idx + 1, True), potential)&#10;&#10;            # deletion allowing further indels&#10;            potential = self._search(st, node, query, query_len, curr_idx,&#10;                                     curr_corrections + 1, max_corrections, True, exact_only)&#10;            if potential.found:&#10;                return potential&#10;            cache_insert_if_better(st, make_key(node.node_id, curr_idx, True), potential)&#10;&#10;        # Store this node's best result and return&#10;        cache_insert_if_better(st, node_key, result)&#10;        return result&#10;&#10;    def __dealloc__(self):&#10;        self._free_node(self.root)&#10;&#10;    cdef void _free_node(self, TrieNode* node):&#10;        if not node:&#10;            return&#10;        cdef size_t i, m&#10;        m = n_children(node)&#10;        for i in range(m):&#10;            self._free_node(child_at(node, i))&#10;        if node.children_idx != NULL:&#10;            del node.children_idx  # delete C++ vector&#10;        if node.children != NULL:&#10;            free(node.children)  # free C array of children pointers&#10;        if node.collapsed:&#10;            free(node.collapsed)&#10;        if node.leaf_value:&#10;            free(node.leaf_value)&#10;        free(node)&#10;" />
              <option name="updatedContent" value="# distutils: language = c++&#10;# cython: language_level=3, boundscheck=False, wraparound=False, cdivision=True, infer_types=True, initializedcheck=False, nonecheck=False&#10;&#10;from libc.stdlib cimport malloc, free&#10;from libc.stddef cimport size_t&#10;from libc.string cimport strcpy, strlen, memcpy, strncmp, memset&#10;from libcpp.unordered_map cimport unordered_map&#10;from libcpp.utility cimport pair&#10;from libcpp.vector cimport vector&#10;from cython.operator cimport dereference as deref, preincrement as preinc&#10;from cpython.unicode cimport PyUnicode_AsUTF8AndSize, PyUnicode_FromString&#10;import cython&#10;&#10;# -----------------------------&#10;# Low-level string helpers&#10;# -----------------------------&#10;ctypedef char* Str&#10;&#10;cdef Str py_str_to_c_str(str py_str):&#10;    cdef Py_ssize_t n_bytes&#10;    cdef const char* buf = PyUnicode_AsUTF8AndSize(py_str, &amp;n_bytes)&#10;    cdef Str c_str = &lt;Str&gt; malloc(n_bytes + 1)&#10;    if not c_str:&#10;        raise MemoryError(&quot;Failed to allocate memory for C string&quot;)&#10;    memcpy(c_str, buf, n_bytes)&#10;    c_str[n_bytes] = '\0'&#10;    return c_str&#10;&#10;cdef str c_str_to_py_str(const Str c_str):&#10;    if c_str == NULL:&#10;        return None&#10;    return PyUnicode_FromString(c_str)&#10;&#10;# -----------------------------&#10;# Trie node &amp; construction&#10;# -----------------------------&#10;&#10;ctypedef struct Alphabet:&#10;    size_t size&#10;    int map[256]  # Assuming ASCII, max 256 characters&#10;&#10;cdef struct TrieNode:&#10;    int node_id&#10;    char value&#10;    Str collapsed&#10;    size_t collapsed_len&#10;    TrieNode** children&#10;    vector[int]* children_idx&#10;    TrieNode* skip_to&#10;    TrieNode* parent&#10;    Str leaf_value&#10;&#10;cdef TrieNode* create_node(const int node_id, const char value, TrieNode* parent, const size_t alphabet_size):&#10;    cdef TrieNode* node = &lt;TrieNode*&gt;malloc(sizeof(TrieNode))&#10;    if not node:&#10;        raise MemoryError(&quot;Failed to allocate memory for TrieNode&quot;)&#10;    node.node_id = node_id&#10;    node.value = value&#10;    node.collapsed = NULL&#10;    node.skip_to = NULL&#10;    node.children = &lt;TrieNode**&gt; malloc(alphabet_size * sizeof(TrieNode*))  # Allocate space for children pointers&#10;    if not node.children:&#10;        raise MemoryError(&quot;Failed to allocate memory for TrieNode children&quot;)&#10;    memset(node.children, 0, alphabet_size * sizeof(TrieNode*))  # Initialize to NULL&#10;    node.children_idx = new vector[int]()&#10;    deref(node.children_idx).reserve(4)&#10;    node.parent = parent&#10;    node.leaf_value = NULL&#10;    return node&#10;&#10;cdef inline size_t n_children(const TrieNode* n) noexcept nogil:&#10;    return deref(n.children_idx).size()&#10;&#10;cdef inline TrieNode* child_at(const TrieNode* n, const size_t i) noexcept nogil:&#10;    cdef int idx = deref(n.children_idx)[i]&#10;    return n.children[idx]&#10;&#10;cdef inline void append_child_at_index(TrieNode* p, TrieNode* c, int idx) noexcept nogil:&#10;    p.children[idx] = c&#10;    c.parent = p&#10;    deref(p.children_idx).push_back(idx)&#10;&#10;cdef inline bint is_leaf(const TrieNode* node) noexcept nogil:&#10;    return n_children(node) == 0&#10;&#10;cdef inline bint has_complete(const TrieNode* node) noexcept nogil:&#10;    return is_leaf(node) or node.leaf_value != NULL&#10;&#10;# -----------------------------&#10;# Search result POD&#10;# -----------------------------&#10;&#10;cdef struct SearchResult:&#10;    bint found&#10;    Str found_str&#10;    int corrections&#10;&#10;cdef inline bint _is_better(const SearchResult* a, const SearchResult* b) noexcept nogil:&#10;    if a.found != b.found:&#10;        return a.found and not b.found&#10;    return a.corrections &lt; b.corrections&#10;&#10;# -----------------------------&#10;# Pure C++ cache (opaque to Python)&#10;# -----------------------------&#10;&#10;ctypedef unsigned long long Key  # Cache key, bit magic used to hold state&#10;&#10;cdef inline Key make_key(const int node_id, const size_t curr_idx, const bint allow_indels) noexcept nogil:&#10;    return ((&lt;unsigned long long&gt; node_id) &lt;&lt; 33) | ((&lt;unsigned long long&gt; curr_idx) &lt;&lt; 1) | (&#10;        &lt;unsigned long long&gt; (allow_indels &amp; 1))&#10;&#10;cdef struct CacheState:&#10;    unordered_map[Key, SearchResult]* data&#10;&#10;cdef inline CacheState* cache_new() nogil:&#10;    cdef CacheState* st = &lt;CacheState*&gt; malloc(sizeof(CacheState))&#10;    if st == NULL:&#10;        with gil:&#10;            raise MemoryError(&quot;Failed to allocate CacheState&quot;)&#10;    st.data = new unordered_map[Key, SearchResult]()&#10;    return st&#10;&#10;cdef inline void cache_reserve(CacheState* st, size_t query_len) noexcept nogil:&#10;    # Speed up allocations by pre-reserving a rough guesstimate on initial size&#10;    deref(st.data).reserve(8 * query_len)&#10;&#10;cdef inline void cache_free(CacheState* st) noexcept nogil:&#10;    if st != NULL:&#10;        if st.data != NULL:&#10;            del st.data  # delete C++ unordered_map&#10;        free(st)&#10;&#10;cdef inline bint cache_contains(const CacheState* st, const Key key) noexcept nogil:&#10;    return deref(st.data).find(key) != deref(st.data).end()&#10;&#10;cdef inline SearchResult cache_get(const CacheState* st, const Key key) noexcept nogil:&#10;    cdef unordered_map[Key, SearchResult].iterator it&#10;    cdef SearchResult out&#10;    out.found = False&#10;    out.found_str = NULL&#10;    out.corrections = 0&#10;    it = deref(st.data).find(key)&#10;    if it != deref(st.data).end():&#10;        out = deref(it).second&#10;    return out&#10;&#10;cdef inline bint cache_insert_if_better(CacheState* st, Key key, SearchResult incoming) noexcept nogil:&#10;    cdef unordered_map[Key, SearchResult].iterator it&#10;    cdef pair[Key, SearchResult] p&#10;    it = deref(st.data).find(key)&#10;    if it == deref(st.data).end():&#10;        p.first = key&#10;        p.second = incoming&#10;        deref(st.data).insert(p)&#10;        return True&#10;    else:&#10;        if _is_better(&amp;incoming, &amp;deref(it).second):&#10;            deref(it).second = incoming&#10;            return True&#10;        else:&#10;            return False&#10;&#10;# -----------------------------&#10;# Trie object (only search() exposed to Python)&#10;# -----------------------------&#10;@cython.final&#10;@cython.no_gc&#10;cdef class cPrefixTrie:&#10;    cdef TrieNode* root&#10;    cdef int n_entries&#10;    cdef bint allow_indels&#10;    cdef Alphabet alphabet&#10;&#10;    def __init__(self, entries: list[str], allow_indels: bool=False):&#10;        # Scan for alphabet to optimize lookups&#10;        cdef bint[256] seen&#10;        cdef int i, j&#10;        cdef Str c_entry&#10;        cdef str entry&#10;        for i in range(256):&#10;            seen[i] = 0&#10;        for entry in entries:&#10;            c_entry = py_str_to_c_str(entry)&#10;            for j in range(&lt;int&gt; strlen(c_entry)):&#10;                seen[&lt;unsigned char&gt; c_entry[j]] = True&#10;            free(c_entry)&#10;        self.alphabet.size = 0&#10;        for i in range(256):&#10;            if seen[i]:&#10;                self.alphabet.map[i] = &lt;int&gt; self.alphabet.size&#10;                self.alphabet.size += 1&#10;            else:&#10;                self.alphabet.map[i] = -1&#10;&#10;        self.root = create_node(0, '\0', NULL, &lt;size_t&gt; self.alphabet.size)&#10;        self.n_entries = 0&#10;        self.allow_indels = allow_indels&#10;        cdef int last_id = 1&#10;        for entry in entries:&#10;            last_id = self._insert(entry, last_id)&#10;            self.n_entries += 1&#10;        self._compile(self.root)&#10;&#10;    cdef int _insert(self, str entry, size_t last_id):&#10;        cdef TrieNode* node = self.root&#10;        cdef char ch&#10;        cdef bint found&#10;        cdef TrieNode* last_node = NULL&#10;        cdef TrieNode* new_node = NULL&#10;        cdef Str c_entry = py_str_to_c_str(entry)&#10;        cdef size_t i, k, n = strlen(c_entry)&#10;        cdef int idx, idx_next&#10;&#10;        for i in range(n):&#10;            ch = c_entry[i]&#10;            idx = self.alphabet.map[&lt;unsigned char&gt; ch]&#10;            if idx &lt; 0:&#10;                raise ValueError(&quot;Character not in alphabet&quot;)&#10;            if node.children[idx] != NULL:&#10;                node = node.children[idx]&#10;            else:&#10;                for k in range(n-1, i-1, -1):&#10;                    new_node = create_node(last_id, c_entry[k], NULL, &lt;size_t&gt; self.alphabet.size)&#10;                    last_id += 1&#10;                    if k == n - 1:&#10;                        new_node.leaf_value = &lt;Str&gt; malloc(strlen(c_entry) + 1)&#10;                        if not new_node.leaf_value:&#10;                            raise MemoryError(&quot;Failed to allocate memory for leaf value&quot;)&#10;                        strcpy(new_node.leaf_value, c_entry)&#10;                    if last_node != NULL:&#10;                        idx_next = self.alphabet.map[&lt;unsigned char&gt; last_node.value]&#10;                        append_child_at_index(new_node, last_node, idx_next)&#10;                    last_node = new_node&#10;                append_child_at_index(node, last_node, idx)&#10;                break&#10;&#10;        free(c_entry)&#10;        return last_id&#10;&#10;    cdef void _compile(self, TrieNode* node):&#10;        cdef size_t i&#10;        cdef TrieNode* child&#10;        cdef size_t clen&#10;        if not node:&#10;            return&#10;&#10;        if has_complete(node):&#10;            node.collapsed = &lt;Str&gt;malloc(2)&#10;            if not node.collapsed:&#10;                raise MemoryError(&quot;Failed to allocate memory for collapsed value&quot;)&#10;            node.collapsed[0] = node.value&#10;            node.collapsed[1] = '\0'&#10;            node.collapsed_len = 1&#10;            node.skip_to = node&#10;            if is_leaf(node):  # It is a leaf, so we are done&#10;                return&#10;&#10;        if n_children(node) == 1:&#10;            self._compile(child_at(node, 0))&#10;            # Root (value == '\0') should not prefix its value&#10;            if node.value == '\0':&#10;                node.collapsed = &lt;Str&gt;malloc(strlen(child_at(node, 0).collapsed) + 1)&#10;                if not node.collapsed:&#10;                    raise MemoryError(&quot;Failed to allocate memory for collapsed value&quot;)&#10;                strcpy(node.collapsed, child_at(node, 0).collapsed)&#10;                node.collapsed_len = child_at(node, 0).collapsed_len&#10;            else:&#10;                clen = child_at(node, 0).collapsed_len&#10;                node.collapsed = &lt;Str&gt;malloc(clen + 2)  # +1 for node.value, +1 for '\0'&#10;                if not node.collapsed:&#10;                    raise MemoryError(&quot;Failed to allocate memory for collapsed value&quot;)&#10;                node.collapsed[0] = node.value&#10;                strcpy(node.collapsed + 1, child_at(node, 0).collapsed)&#10;                node.collapsed_len = clen + (1 if node.value != '\0' else 0)&#10;            node.skip_to = child_at(node, 0).skip_to&#10;        else:&#10;            for i in range(n_children(node)):&#10;                child = child_at(node, i)&#10;                self._compile(child)&#10;            node.collapsed = &lt;Str&gt;malloc(2)&#10;            if not node.collapsed:&#10;               raise MemoryError(&quot;Failed to allocate memory for collapsed value&quot;)&#10;            node.collapsed[0] = node.value&#10;            node.collapsed[1] = '\0'&#10;            node.collapsed_len = 1&#10;            node.skip_to = node&#10;&#10;    cpdef tuple[object, bint] search(self, str query, int correction_budget=0):&#10;        cdef Str c_query = py_str_to_c_str(query)&#10;        cdef object found_str_py = None&#10;        cdef size_t query_len = strlen(c_query)&#10;        cdef CacheState* st = cache_new()&#10;        cache_reserve(st, query_len)  # Pre-allocate some space&#10;        cdef SearchResult res&#10;        with nogil:&#10;            res = self._search(&#10;                st, self.root, c_query, query_len,&#10;                0, 0, correction_budget, self.allow_indels, False&#10;            )&#10;        if res.found:&#10;            found_str_py = c_str_to_py_str(res.found_str)&#10;        cdef bint exact = res.found and (res.corrections == 0)&#10;        cache_free(st)  # frees all owned SearchResult*&#10;        free(c_query)&#10;        return (found_str_py, exact)&#10;&#10;    cdef SearchResult _search(self,&#10;                               CacheState* st,&#10;                               TrieNode* node,&#10;                               Str query,&#10;                               size_t query_len,&#10;                               size_t curr_idx,&#10;                               int curr_corrections,&#10;                               int max_corrections,&#10;                               bint allow_indels,&#10;                               bint exact_only) noexcept nogil:&#10;        # If there is no more remaining corrections, we can get some speed ups by annotating exact_only as true&#10;        exact_only = exact_only or (curr_corrections &gt;= max_corrections)&#10;&#10;        cdef SearchResult result&#10;        cdef SearchResult potential&#10;        cdef SearchResult prev&#10;        cdef bint is_at_query_end = (query_len == curr_idx)&#10;        cdef size_t i&#10;        cdef char query_char&#10;        cdef size_t skip_len&#10;        cdef size_t m  # Move variable declaration to top&#10;        cdef int want&#10;        cdef int idx_child&#10;        cdef int ai&#10;&#10;        result.found = False&#10;        result.corrections = curr_corrections&#10;        result.found_str = NULL&#10;&#10;        # Cache check&#10;        cdef Key node_key = make_key(node.node_id, curr_idx, allow_indels)&#10;        prev = cache_get(st, node_key)&#10;        if cache_contains(st, node_key):&#10;            prev = cache_get(st, node_key)&#10;            if prev.corrections &lt;= curr_corrections:&#10;                return prev&#10;&#10;        # Base cases&#10;        if is_at_query_end and has_complete(node):&#10;            result.found = True&#10;            result.found_str = node.leaf_value&#10;            if not cache_insert_if_better(st, node_key, result):&#10;                return cache_get(st, node_key)&#10;            return result&#10;&#10;        # If we reached a complete node but haven't consumed all the query, this is only valid with indels&#10;        if has_complete(node) and not is_at_query_end:&#10;            if allow_indels and curr_corrections &lt; max_corrections:&#10;                # We can match here but need to add corrections for remaining query characters&#10;                remaining_chars = query_len - curr_idx&#10;                if curr_corrections + remaining_chars &lt;= max_corrections:&#10;                    result.found = True&#10;                    result.found_str = node.leaf_value&#10;                    result.corrections = curr_corrections + remaining_chars&#10;                    if not cache_insert_if_better(st, node_key, result):&#10;                        return cache_get(st, node_key)&#10;                    return result&#10;&#10;        if is_at_query_end and (not allow_indels or curr_corrections &gt;= max_corrections):&#10;            if not cache_insert_if_better(st, node_key, result):&#10;                return cache_get(st, node_key)&#10;            return result&#10;&#10;        if (not is_at_query_end) and is_leaf(node) and (not allow_indels or curr_corrections &gt;= max_corrections):&#10;            if not cache_insert_if_better(st, node_key, result):&#10;                return cache_get(st, node_key)&#10;            return result&#10;&#10;        # Collapsed exact skip&#10;        if node.collapsed is not NULL and node.skip_to is not NULL and node.skip_to != node:&#10;            skip_len = node.collapsed_len&#10;            # For exact skip, the collapsed path must match AND we must be able to consume it exactly&#10;            if curr_idx + skip_len &lt;= query_len and strncmp(node.collapsed, query + curr_idx, skip_len) == 0:&#10;                # Only do exact skip if we're at the end of query or if we're allowing corrections&#10;                if curr_idx + skip_len == query_len or allow_indels:&#10;                    potential = self._search(st, node.skip_to, query, query_len, curr_idx + skip_len,&#10;                                             curr_corrections, max_corrections, allow_indels, exact_only)&#10;                    if potential.found and (exact_only or potential.corrections &lt;= curr_corrections or not allow_indels):&#10;                        return potential&#10;                    # Otherwise cache it and continue exploring&#10;                    cache_insert_if_better(st, make_key(node.skip_to.node_id, curr_idx + skip_len, allow_indels), potential)&#10;&#10;        # Exact character match (O(1) via alphabet index)&#10;        if curr_idx &lt; query_len:&#10;            query_char = query[curr_idx]&#10;            ai = self.alphabet.map[&lt;unsigned char&gt; query_char]&#10;            if ai &gt;= 0:&#10;                if node.children[ai] != NULL:&#10;                    potential = self._search(st, node.children[ai], query, query_len, curr_idx + 1,&#10;                                             curr_corrections, max_corrections, allow_indels, exact_only)&#10;                    if potential.found:&#10;                        return potential&#10;                    cache_insert_if_better(st, make_key(node.children[ai].node_id, curr_idx + 1, allow_indels), potential)&#10;&#10;        # No budget to correct&#10;        if exact_only or curr_corrections &gt;= max_corrections:&#10;            if not cache_insert_if_better(st, node_key, result):&#10;                return cache_get(st, node_key)&#10;            else:&#10;                return result&#10;&#10;        # Try mismatches (iterate only existing children indices)&#10;        if curr_idx &lt; query_len:&#10;            query_char = query[curr_idx]&#10;            want = self.alphabet.map[&lt;unsigned char&gt; query_char]&#10;            m = n_children(node)&#10;            for i in range(m):&#10;                idx_child = deref(node.children_idx)[i]&#10;                if idx_child == want:&#10;                    continue&#10;                potential = self._search(st, node.children[idx_child], query, query_len, curr_idx + 1,&#10;                                         curr_corrections + 1, max_corrections, allow_indels, exact_only)&#10;                if potential.found:&#10;                    return potential&#10;                cache_insert_if_better(st, make_key(node.children[idx_child].node_id, curr_idx + 1, allow_indels), potential)&#10;&#10;        # Try indels if allowed&#10;        if allow_indels:&#10;            # Insertion: advance in trie (consume trie character) while staying at same query position&#10;            # This simulates inserting a character from the trie into the query&#10;            m = n_children(node)&#10;            for i in range(m):&#10;                idx_child = deref(node.children_idx)[i]&#10;                potential = self._search(st, node.children[idx_child], query, query_len, curr_idx,&#10;                                         curr_corrections + 1, max_corrections, True, exact_only)&#10;                if potential.found:&#10;                    return potential&#10;                cache_insert_if_better(st, make_key(node.children[idx_child].node_id, curr_idx, True), potential)&#10;&#10;            # Deletion: advance query index while staying at same trie node&#10;            # This simulates deleting a character from the query&#10;            if curr_idx &lt; query_len:&#10;                potential = self._search(st, node, query, query_len, curr_idx + 1,&#10;                                         curr_corrections + 1, max_corrections, True, exact_only)&#10;                if potential.found:&#10;                    return potential&#10;                cache_insert_if_better(st, make_key(node.node_id, curr_idx + 1, True), potential)&#10;&#10;        # Store this node's best result and return&#10;        cache_insert_if_better(st, node_key, result)&#10;        return result&#10;&#10;    def __dealloc__(self):&#10;        self._free_node(self.root)&#10;&#10;    cdef void _free_node(self, TrieNode* node):&#10;        if not node:&#10;            return&#10;        cdef size_t i, m&#10;        m = n_children(node)&#10;        for i in range(m):&#10;            self._free_node(child_at(node, i))&#10;        if node.children_idx != NULL:&#10;            del node.children_idx  # delete C++ vector&#10;        if node.children != NULL:&#10;            free(node.children)  # free C array of children pointers&#10;        if node.collapsed:&#10;            free(node.collapsed)&#10;        if node.leaf_value:&#10;            free(node.leaf_value)&#10;        free(node)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>