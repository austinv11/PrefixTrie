{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PrefixTrie","text":"<p>A high-performance Cython implementation of a prefix trie data structure for efficient fuzzy string matching. Originally designed for RNA barcode matching in bioinformatics applications, but suitable for any use case requiring fast approximate string search.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ultra-fast exact matching using optimized Python sets</li> <li>Fuzzy matching with configurable edit distance (insertions, deletions, substitutions)</li> <li>Substring search to find trie entries within larger strings</li> <li>Longest prefix matching for sequence analysis</li> <li>Mutable and immutable trie variants</li> <li>Multiprocessing support with pickle compatibility</li> <li>Shared memory for high-performance parallel processing</li> <li>Memory-efficient with collapsed node optimization</li> <li>Bioinformatics-optimized for DNA/RNA/protein sequences</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Our Getting Started Guide provides a step-by-step introduction to installing and using PrefixTrie.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>For detailed API documentation, see the API Reference.</p>"},{"location":"#performance","title":"Performance","text":"<p>PrefixTrie is highly optimized and typically outperforms similar fuzzy matching libraries:</p> <ul> <li>Search Performance: Substantially faster than RapidFuzz, TheFuzz, and SymSpell</li> <li>Substring Search: At least on par with fuzzysearch and regex, often faster</li> <li>Memory Efficiency: Collapsed node optimization reduces memory footprint</li> <li>Parallel Processing: Full pickle support for multiprocessing workflows</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page contains a collection of examples demonstrating how to use PrefixTrie for various tasks.</p>"},{"location":"examples/#basic-search-operations","title":"Basic Search Operations","text":"<pre><code>from prefixtrie import PrefixTrie\n\n# Create a trie\ntrie = PrefixTrie([\"ACGT\", \"ACGG\", \"ACGC\"], allow_indels=True)\n\n# Search with different correction budgets\nresult, corrections = trie.search(\"ACGT\", correction_budget=0)  # Exact match\nprint(f\"Found '{result}' with {corrections} corrections.\")\n\nresult, corrections = trie.search(\"ACGA\", correction_budget=1)  # Allow 1 edit\nprint(f\"Found '{result}' with {corrections} corrections.\")\n</code></pre>"},{"location":"examples/#substring-search","title":"Substring Search","text":"<p>Find trie entries that appear as substrings within larger strings.</p> <pre><code>from prefixtrie import PrefixTrie\n\ntrie = PrefixTrie([\"HELLO\", \"WORLD\"])\n\n# Find trie entries within larger strings\nresult, corrections, start, end = trie.search_substring(\"AAAAHELLOAAAA\", correction_budget=0)\nprint(f\"Found '{result}' at positions {start}:{end}\")\n</code></pre>"},{"location":"examples/#longest-prefix-matching","title":"Longest Prefix Matching","text":"<p>Find the longest prefix from the trie that matches the beginning of a target string.</p> <pre><code>from prefixtrie import PrefixTrie\n\ntrie = PrefixTrie([\"ACGT\", \"ACGTA\", \"ACGTAG\"])\n\n# Find the longest prefix match\nresult, start_pos, match_length = trie.longest_prefix_match(\"ACGTAGGT\", min_match_length=4)\nprint(f\"Longest match: '{result}' at position {start_pos}, length {match_length}\")\n</code></pre>"},{"location":"examples/#counting-matches","title":"Counting Matches","text":"<p>Count how many entries match a query within a given correction budget.</p> <pre><code>from prefixtrie import PrefixTrie\n\ntrie = PrefixTrie([\"apple\", \"apply\", \"apples\", \"orange\"])\n\n# Count how many entries match a query\ncount = trie.search_count(\"apple\", correction_budget=1)\nprint(f\"Found {count} match(es) for 'apple' with budget 1.\")\n</code></pre>"},{"location":"examples/#mutable-operations","title":"Mutable Operations","text":"<p>Create a mutable trie to dynamically add and remove entries.</p> <pre><code>from prefixtrie import PrefixTrie\n\n# Create a mutable trie for dynamic modifications\ntrie = PrefixTrie([\"apple\"], immutable=False, allow_indels=True)\nprint(f\"Initial trie: {list(trie)}\")\n\ntrie.add(\"banana\")\nprint(f\"After adding 'banana': {list(trie)}\")\n\ntrie.remove(\"apple\")\nprint(f\"After removing 'apple': {list(trie)}\")\n</code></pre>"},{"location":"examples/#standard-dictionary-interface","title":"Standard Dictionary Interface","text":"<p>PrefixTrie supports standard Python container operations, making it feel like a regular Python dictionary.</p> <pre><code>from prefixtrie import PrefixTrie\n\ntrie = PrefixTrie([\"apple\", \"banana\", \"cherry\"])\n\n# Length\nprint(f\"Size of trie: {len(trie)}\")\n\n# Membership testing\nprint(f\"'apple' in trie: {'apple' in trie}\")\nprint(f\"'grape' in trie: {'grape' in trie}\")\n\n# Item access\nprint(f\"Accessing 'banana': {trie['banana']}\")\n\n# Iteration\nprint(\"Iterating over trie:\")\nfor item in trie:\n    print(f\"- {item}\")\n\n# String representation\nprint(f\"String representation: {repr(trie)}\")\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will walk you through the installation and basic usage of PrefixTrie.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install PrefixTrie directly from PyPI using pip:</p> <pre><code>pip install prefixtrie\n</code></pre> <p>This will install the latest stable version of the library.</p>"},{"location":"getting-started/#your-first-trie","title":"Your First Trie","text":"<p>Let's create your first prefix trie and perform a simple search.</p> <pre><code>from prefixtrie import PrefixTrie\n\n# 1. Create a trie with a list of strings\ntrie = PrefixTrie([\"ACGT\", \"ACGG\", \"ACGC\"])\n\n# 2. Perform an exact search\n# The search function returns the matched string and the number of corrections.\nresult, corrections = trie.search(\"ACGT\")\n\nprint(f\"Found '{result}' with {corrections} corrections.\")\n# Expected output: Found 'ACGT' with 0 corrections.\n</code></pre>"},{"location":"getting-started/#fuzzy-matching","title":"Fuzzy Matching","text":"<p>PrefixTrie shines when it comes to fuzzy matching. You can specify a <code>correction_budget</code> to allow for a certain number of edits (insertions, deletions, or substitutions).</p> <p>By default, <code>allow_indels</code> is <code>False</code>, so only substitutions are allowed. To allow insertions and deletions, you need to set <code>allow_indels=True</code> when creating the trie.</p> <pre><code>from prefixtrie import PrefixTrie\n\n# Create a trie that allows insertions and deletions\ntrie = PrefixTrie([\"ACGT\", \"ACGG\", \"ACGC\"], allow_indels=True)\n\n# 1. Fuzzy matching with one substitution\nresult, corrections = trie.search(\"ACGA\", correction_budget=1)\nprint(f\"Found '{result}' with {corrections} correction(s).\")\n# Expected output: Found 'ACGT' with 1 correction(s).\n\n# 2. Fuzzy matching with one insertion\nresult, corrections = trie.search(\"ACG\", correction_budget=1)\nprint(f\"Found '{result}' with {corrections} correction(s).\")\n# Expected output: Found 'ACGT' with 1 correction(s).\n\n# 3. Fuzzy matching with one deletion\nresult, corrections = trie.search(\"ACGTA\", correction_budget=1)\nprint(f\"Found '{result}' with {corrections} correction(s).\")\n# Expected output: Found 'ACGT' with 1 correction(s).\n</code></pre>"},{"location":"getting-started/#additional-examples","title":"Additional Examples","text":"<p>This page has gone over the absolute basics, to see more examples and use cases, check out the Examples page.</p>"},{"location":"reference/","title":"API Reference","text":"<p>This page contains the complete API documentation for PrefixTrie, automatically generated from the source code docstrings.</p>"},{"location":"reference/#prefixtrie.PrefixTrie","title":"<code>PrefixTrie(entries, allow_indels=False, immutable=True, shared_memory_name=None)</code>","text":"<p>Thin wrapper around the cPrefixTrie class to provide a Python interface.</p> <p>Initialize the PrefixTrie with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>list[str]</code> <p>List of strings to be added to the trie.</p> required <code>allow_indels</code> <code>bool</code> <p>If True, allows insertions and deletions in the trie</p> <code>False</code> <code>immutable</code> <code>bool</code> <p>If True, the trie cannot be modified after creation</p> <code>True</code> <code>shared_memory_name</code> <code>str</code> <p>If provided, load from existing shared memory block</p> <code>None</code>"},{"location":"reference/#prefixtrie.PrefixTrie-functions","title":"Functions","text":""},{"location":"reference/#prefixtrie.PrefixTrie.create_shared_memory","title":"<code>create_shared_memory(name=None)</code>","text":"<p>Create a shared memory block containing this trie's data. Returns the name of the shared memory block. Note: Shared memory requires the trie to be immutable.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Optional name for the shared memory block</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Name of the created shared memory block</p>"},{"location":"reference/#prefixtrie.PrefixTrie.cleanup_shared_memory","title":"<code>cleanup_shared_memory()</code>","text":"<p>Clean up shared memory if this instance owns it</p>"},{"location":"reference/#prefixtrie.PrefixTrie.search","title":"<code>search(item, correction_budget=0)</code>","text":"<p>Search for an item in the trie with optional corrections.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The string to search for in the trie.</p> required <code>correction_budget</code> <code>int</code> <p>Maximum number of corrections allowed (default is 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[str | None, int]</code> <p>A tuple containing the found item and the number of corrections, or (None, -1) if not found.</p>"},{"location":"reference/#prefixtrie.PrefixTrie.search_substring","title":"<code>search_substring(target_string, correction_budget=0)</code>","text":"<p>Search for fuzzy substring matches of trie entries within a target string.</p> <p>This method finds any entry from the trie that appears as a fuzzy substring within the target string, allowing for insertions, deletions, and substitutions.</p> <p>Parameters:</p> Name Type Description Default <code>target_string</code> <code>str</code> <p>The string to search within for trie entries</p> required <code>correction_budget</code> <code>int</code> <p>Maximum number of edits allowed (default is 0)</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[str | None, int, int, int]</code> <p>Tuple of (found_string, corrections, start_pos, end_pos) or (None, -1, -1, -1) where start_pos and end_pos indicate the location of the match in target_string</p>"},{"location":"reference/#prefixtrie.PrefixTrie.longest_prefix_match","title":"<code>longest_prefix_match(target, min_match_length, correction_budget=0)</code>","text":"<p>Find the longest prefix match in the trie for the given target string.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The target string to find the longest prefix match for.</p> required <code>min_match_length</code> <code>int</code> <p>Minimum length of the match to be considered valid.</p> required <code>correction_budget</code> <code>int</code> <p>Maximum number of corrections allowed (default is 0 for exact matching).</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[str | None, int, int]</code> <p>A tuple containing the longest matching prefix, the target start index, and the match length.</p>"},{"location":"reference/#prefixtrie.PrefixTrie.search_count","title":"<code>search_count(query, correction_budget=0)</code>","text":"<p>Count the number of entries that fit a query string within a correction budget.</p> <p>This method is optimized for efficiently counting all possible matches without returning the actual strings.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string to match against the trie entries.</p> required <code>correction_budget</code> <code>int</code> <p>Maximum number of corrections allowed (default is 0).</p> <code>0</code> <p>Returns:</p> Type Description <code>int</code> <p>The count of matching entries within the correction budget.</p>"},{"location":"reference/#prefixtrie.PrefixTrie.add","title":"<code>add(entry)</code>","text":"<p>Add a new entry to the trie (only if mutable).</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>str</code> <p>The string to add</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if added successfully, False if already exists or trie is immutable</p>"},{"location":"reference/#prefixtrie.PrefixTrie.remove","title":"<code>remove(entry)</code>","text":"<p>Remove an entry from the trie (only if mutable).</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>str</code> <p>The string to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if removed successfully, False if not found or trie is immutable</p>"},{"location":"reference/#prefixtrie.PrefixTrie.is_immutable","title":"<code>is_immutable()</code>","text":"<p>Check if the trie is immutable.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if immutable, False if mutable</p>"}]}